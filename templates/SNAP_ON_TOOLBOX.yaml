# ═══════════════════════════════════════════════════════════════════════════════
# SNAP-ON TOOLBOX - MASTER REGISTRY
# ═══════════════════════════════════════════════════════════════════════════════
# Authority: imo-creator (Constitutional)
# Status: LOCKED - Claude Code MUST read before suggesting any tool
# Location: imo-creator/templates/SNAP_ON_TOOLBOX.yaml
# ═══════════════════════════════════════════════════════════════════════════════

version: "2.0.0"
last_updated: "2026-01-28"
doctrine: "Snap-on - One tool, many jobs, config is the variable"

# ═══════════════════════════════════════════════════════════════════════════════
# EVALUATION CRITERIA
# ═══════════════════════════════════════════════════════════════════════════════
criteria:
  tier_0_free:
    definition: "Claude Code, existing infra, stdlib, free APIs"
    cost: "$0"
    priority: "Build first"

  tier_1_cheap:
    definition: "< $0.01/call or fixed subscription already owned"
    cost: "Minimal"
    priority: "Use freely within limits"

  tier_2_surgical:
    definition: "Per-call cost, gated by business rules"
    cost: "Pay-per-use"
    priority: "Fire only when criteria met"

# ═══════════════════════════════════════════════════════════════════════════════
# EVALUATION ORDER (MANDATORY)
# ═══════════════════════════════════════════════════════════════════════════════
evaluation_order:
  - step: 1
    action: "CHECK BANNED LIST FIRST"
    on_match: "STOP — suggest approved alternative"

  - step: 2
    action: "CHECK TIER 0 (FREE)"
    question: "Can this be done with existing free tools?"

  - step: 3
    action: "CHECK TIER 1 (CHEAP)"
    question: "Is there an existing subscription that covers this?"

  - step: 4
    action: "CHECK TIER 2 (SURGICAL)"
    question: "Does this meet gate conditions for paid per-call tools?"

  - step: 5
    action: "IF NOT LISTED"
    on_match: "ASK — may need ADR for new tool"

# ═══════════════════════════════════════════════════════════════════════════════
# TIER 0: GENERIC FREE TOOLS
# ═══════════════════════════════════════════════════════════════════════════════
# These tools are DOMAIN-AGNOSTIC and may be used by any child repo.
# Child repos define their own consumers in their REPO_DOMAIN_SPEC.md.
# ═══════════════════════════════════════════════════════════════════════════════

tools:

  MXLookup:
    tool_id: "TOOL-001"
    tier: 0
    status: "active"
    software:
      primary: "dnspython"
      dependencies: ["dnspython>=2.4"]
      vendor: null
      requires_api_key: false
    purpose:
      summary: "Validates domain has functioning mail server"
      what_it_does:
        - "DNS MX record lookup"
        - "Mail server existence validation"
    throttle:
      rate_limits:
        - {scope: "per_second", limit: 50}
        - {scope: "per_day", limit: 50000}
      cost: {model: "free", estimated_cost_per_call: 0.00}
      backoff: {strategy: "linear", initial_delay_ms: 100, max_retries: 2}
    guardrails:
      kill_switch: {trigger: "dns_resolver_failure", action: "switch_resolver"}
      data_quality: {cache_ttl_hours: 24}
    accuracy: "100%"
    accuracy_notes: "Binary - MX exists or not"

  SMTPCheck:
    tool_id: "TOOL-002"
    tier: 0
    status: "active"
    software:
      primary: "smtplib (stdlib)"
      dependencies: []
      vendor: null
      requires_api_key: false
    purpose:
      summary: "Validates email deliverability via SMTP handshake"
      what_it_does:
        - "SMTP connection test"
        - "RCPT TO validation (where allowed)"
        - "Catch-all detection"
    throttle:
      rate_limits:
        - {scope: "per_domain", limit: 1, window: "2s"}
        - {scope: "per_day", limit: 10000}
      cost: {model: "free", estimated_cost_per_call: 0.00}
      backoff: {strategy: "exponential", initial_delay_ms: 2000, max_retries: 2}
    guardrails:
      kill_switch: {trigger: "ip_blacklist_detected", action: "halt_and_alert"}
      data_quality: {cache_ttl_hours: 168}
    accuracy: "95%"
    accuracy_notes: "Some servers reject all RCPT TO probes"

  LinkedInCheck:
    tool_id: "TOOL-003"
    tier: 0
    status: "active"
    software:
      primary: "httpx"
      dependencies: ["httpx>=0.25"]
      vendor: null
      requires_api_key: false
    purpose:
      summary: "Validates LinkedIn company/profile URL exists"
      what_it_does:
        - "HTTP HEAD request to LinkedIn URL"
        - "200 vs 404 validation"
      what_it_does_NOT_do:
        - "Scrape LinkedIn content (ToS violation)"
    throttle:
      rate_limits:
        - {scope: "per_minute", limit: 30}
        - {scope: "per_day", limit: 1000}
      cost: {model: "free", estimated_cost_per_call: 0.00}
      backoff: {strategy: "exponential", initial_delay_ms: 2000, max_retries: 2}
    guardrails:
      kill_switch: {trigger: "403_or_429_sustained", action: "circuit_break_1h"}
      data_quality: {cache_ttl_hours: 168}
    accuracy: "90%"
    accuracy_notes: "URL exists != person still there"

# ═══════════════════════════════════════════════════════════════════════════════
# TIER 1: GENERIC CHEAP TOOLS
# ═══════════════════════════════════════════════════════════════════════════════

  Firecrawl:
    tool_id: "TOOL-004"
    tier: 1
    status: "active"
    software:
      primary: "Firecrawl API"
      dependencies: ["httpx>=0.25"]
      vendor: "Firecrawl"
      requires_api_key: true
      api_key_source: "FIRECRAWL_API_KEY"
    purpose:
      summary: "Full page scraping with JS rendering and markdown output"
      what_it_does:
        - "Fetch and render JS-heavy pages"
        - "Convert to clean markdown"
        - "Handle anti-bot measures"
    throttle:
      rate_limits:
        - {scope: "per_minute", limit: 100}
        - {scope: "per_month", limit: 500}
      cost: {model: "freemium", estimated_cost_per_call: 0.00, notes: "500/month free"}
      backoff: {strategy: "exponential", initial_delay_ms: 1000, max_retries: 3}
    guardrails:
      kill_switch: {trigger: "monthly_limit_reached", action: "halt_until_reset"}
    accuracy: "90%"
    accuracy_notes: "Best-in-class for JS rendering"

  ScraperAPI:
    tool_id: "TOOL-005"
    tier: 1
    status: "active"
    software:
      primary: "ScraperAPI"
      dependencies: ["httpx>=0.25"]
      vendor: "ScraperAPI"
      requires_api_key: true
      api_key_source: "SCRAPERAPI_KEY"
    purpose:
      summary: "Anti-bot proxy for difficult targets"
      what_it_does:
        - "Proxy requests through rotating IPs"
        - "Handle CAPTCHAs and blocks"
    throttle:
      rate_limits:
        - {scope: "per_second", limit: 10}
        - {scope: "per_month", limit: 100000}
      cost: {model: "per_call", estimated_cost_per_call: 0.001, monthly_budget_cap: 100}
      backoff: {strategy: "exponential", initial_delay_ms: 2000, max_retries: 3}
    guardrails:
      kill_switch: {trigger: "budget_cap_reached", action: "halt_and_alert"}
    accuracy: "95%"
    accuracy_notes: "High success rate on blocked sites"

  GooglePlaces:
    tool_id: "TOOL-006"
    tier: 1
    status: "active"
    software:
      primary: "Google Places API"
      dependencies: ["httpx>=0.25"]
      vendor: "Google"
      requires_api_key: true
      api_key_source: "GOOGLE_API_KEY"
    purpose:
      summary: "Business validation, address lookup, geocoding"
      what_it_does:
        - "Text search for business types"
        - "Place details lookup"
        - "Address validation and geocoding"
    throttle:
      rate_limits:
        - {scope: "per_second", limit: 10}
        - {scope: "per_day", limit: 1000}
      cost: {model: "per_call", estimated_cost_per_call: 0.017, monthly_budget_cap: 50}
      backoff: {strategy: "exponential", initial_delay_ms: 1000, max_retries: 3}
    guardrails:
      kill_switch: {trigger: "budget_cap_reached OR daily_limit", action: "halt_and_alert"}
      data_quality: {cache_ttl_days: 30}
    accuracy: "98%"
    accuracy_notes: "Google source of truth for places"

  ComposioRouter:
    tool_id: "TOOL-007"
    tier: 1
    status: "active"
    software:
      primary: "Composio"
      dependencies: []
      vendor: "Composio"
      requires_api_key: true
      api_key_source: "COMPOSIO_API_KEY"
    purpose:
      summary: "Integration router for 500+ apps"
      what_it_does:
        - "Gmail send/read"
        - "Slack notifications"
        - "Google Sheets read/write"
        - "500+ more via single interface"
    throttle:
      rate_limits:
        - {scope: "per_app_per_minute", limit: 60}
      cost: {model: "monthly_fixed", monthly_cost: 30.00}
      backoff: {strategy: "exponential", initial_delay_ms: 1000, max_retries: 3}
    guardrails:
      kill_switch: {trigger: "auth_failure_sustained", action: "halt_and_alert"}
    accuracy: "95%"
    accuracy_notes: "Depends on downstream app"

# ═══════════════════════════════════════════════════════════════════════════════
# TIER 2: GENERIC SURGICAL TOOLS (Gated)
# ═══════════════════════════════════════════════════════════════════════════════
# Gate conditions are DEFINED BY CHILD REPOS in their REPO_DOMAIN_SPEC.md.
# Parent only specifies that gates MUST exist.
# ═══════════════════════════════════════════════════════════════════════════════

  HunterEnricher:
    tool_id: "TOOL-008"
    tier: 2
    status: "active"
    software:
      primary: "Hunter.io API"
      dependencies: ["httpx>=0.25"]
      vendor: "Hunter.io"
      requires_api_key: true
      api_key_source: "HUNTER_API_KEY"
    purpose:
      summary: "Email finder and domain search"
      what_it_does:
        - "Find email by name + domain"
        - "Domain email pattern detection"
    gate:
      required: true
      note: "Child repo MUST define gate conditions in REPO_DOMAIN_SPEC.md"
      max_attempts_per_context: 1
    throttle:
      rate_limits:
        - {scope: "per_second", limit: 10}
        - {scope: "per_month", limit: 1000}
      cost: {model: "per_call", estimated_cost_per_call: 0.008, monthly_budget_cap: 100}
      backoff: {strategy: "exponential", initial_delay_ms: 1000, max_retries: 2}
    guardrails:
      kill_switch: {trigger: "budget_cap_reached", action: "halt_and_alert"}
      firewall: {check_gate_before_call: true, log_all_calls: true}
    accuracy: "85%"
    accuracy_notes: "Pattern-based, verify before send"

  ApolloEnricher:
    tool_id: "TOOL-009"
    tier: 2
    status: "active"
    software:
      primary: "Apollo.io API"
      dependencies: ["httpx>=0.25"]
      vendor: "Apollo.io"
      requires_api_key: true
      api_key_source: "APOLLO_API_KEY"
    purpose:
      summary: "Contact and company enrichment"
      what_it_does:
        - "People search by company + title"
        - "Email + phone enrichment"
        - "Company firmographics"
    gate:
      required: true
      note: "Child repo MUST define gate conditions in REPO_DOMAIN_SPEC.md"
      max_attempts_per_context: 1
    throttle:
      rate_limits:
        - {scope: "per_minute", limit: 60}
        - {scope: "per_month", limit: 2000}
      cost: {model: "per_call", estimated_cost_per_call: 0.005, monthly_budget_cap: 100}
      backoff: {strategy: "exponential", initial_delay_ms: 1000, max_retries: 2}
    guardrails:
      kill_switch: {trigger: "budget_cap_reached", action: "halt_and_alert"}
      firewall: {check_gate_before_call: true, log_all_calls: true}
    accuracy: "80%"
    accuracy_notes: "Data freshness varies"

  EmailVerifier:
    tool_id: "TOOL-010"
    tier: 2
    status: "active"
    software:
      primary: "MillionVerifier API"
      dependencies: ["httpx>=0.25"]
      vendor: "MillionVerifier"
      requires_api_key: true
      api_key_source: "MILLIONVERIFIER_API_KEY"
    purpose:
      summary: "Pre-send email verification"
      what_it_does:
        - "Real-time email validation"
        - "Catch-all detection"
        - "Disposable email detection"
    gate:
      required: true
      note: "Child repo MUST define gate conditions in REPO_DOMAIN_SPEC.md"
      max_attempts_per_email: 1
    throttle:
      rate_limits:
        - {scope: "per_second", limit: 50}
        - {scope: "per_month", limit: 10000}
      cost: {model: "per_call", estimated_cost_per_call: 0.004, monthly_budget_cap: 50}
      backoff: {strategy: "linear", initial_delay_ms: 500, max_retries: 2}
    guardrails:
      kill_switch: {trigger: "budget_cap_reached", action: "halt_and_alert"}
      data_quality: {cache_result: true, cache_ttl_days: 90}
    accuracy: "98%"
    accuracy_notes: "Industry-leading accuracy"

  RetellCaller:
    tool_id: "TOOL-011"
    tier: 2
    status: "active"
    software:
      primary: "Retell AI API"
      dependencies: ["httpx>=0.25"]
      vendor: "Retell AI"
      requires_api_key: true
      api_key_source: "RETELL_API_KEY"
    purpose:
      summary: "AI voice calling for outreach and validation"
      what_it_does:
        - "Automated voice calls"
        - "Conversation transcription"
        - "Lead qualification"
    gate:
      required: true
      note: "Child repo MUST define gate conditions in REPO_DOMAIN_SPEC.md"
      human_approval_required: true
      max_attempts_per_contact: 3
    throttle:
      rate_limits:
        - {scope: "concurrent_calls", limit: 10}
        - {scope: "per_day", limit: 100}
      cost: {model: "per_minute", estimated_cost_per_minute: 0.07, monthly_budget_cap: 200}
      backoff: {strategy: "fixed", initial_delay_ms: 5000, max_retries: 1}
    guardrails:
      kill_switch: {trigger: "budget_cap_reached OR complaint_received", action: "halt_immediately"}
      compliance: {require_consent: true, respect_dnc: true, calling_hours: "9am-8pm local"}
    accuracy: "90%"
    accuracy_notes: "Depends on script quality"

# ═══════════════════════════════════════════════════════════════════════════════
# BANNED LIST
# ═══════════════════════════════════════════════════════════════════════════════

banned:
  vendors:
    - {name: "ZoomInfo", reason: "Cost prohibitive"}
    - {name: "Lusha", reason: "Cost prohibitive"}
    - {name: "Seamless.AI", reason: "Cost prohibitive"}
    - {name: "LinkedIn Sales Navigator", reason: "ToS violation + cost"}
    - {name: "Diffbot", reason: "Per-page pricing"}
    - {name: "Clearbit", reason: "Now Breeze, pricing changed, use Apollo"}
    - {name: "Clay", reason: "Margin on top of vendors - go direct"}
    - {name: "Prospeo", reason: "Redundant with Hunter"}
    - {name: "Snov", reason: "Redundant with Hunter"}

  libraries:
    - {name: "selenium", reason: "Use playwright instead"}
    - {name: "requests", reason: "Use httpx instead"}
    - {name: "lxml", reason: "Use selectolax instead"}
    - {name: "scrapy", reason: "Overkill - use targeted fetches"}
    - {name: "beautifulsoup4", reason: "Use selectolax (faster)"}

  patterns:
    - {name: "bulk_enrichment", reason: "Violates surgical doctrine"}
    - {name: "llm_as_spine", reason: "LLM is tail arbitration only"}
    - {name: "recursive_crawling", reason: "Cost explosion"}
    - {name: "scraping_linkedin_profiles", reason: "ToS violation"}

# ═══════════════════════════════════════════════════════════════════════════════
# INFRASTRUCTURE (Platform, not tools)
# ═══════════════════════════════════════════════════════════════════════════════

infrastructure:
  ui: {name: "Lovable.dev", role: "UI + Edge Functions", cost: "Subscription"}
  compute: {name: "Supabase Edge Functions", role: "Fast serverless compute", cost: "Free tier"}
  database: {name: "Neon", role: "Vault - source of truth", cost: "Free tier"}
  orchestration: {name: "n8n", role: "Workflow automation", cost: "Self-hosted @ Hostinger"}
  integrations: {name: "Composio", role: "500+ app router", cost: "$30/month fixed"}
  secrets: {name: "Doppler", role: "Secrets management", cost: "Free tier"}
  ci_cd: {name: "GitHub Actions", role: "CI/CD pipelines", cost: "Free tier"}

# ═══════════════════════════════════════════════════════════════════════════════
# TOOL DEFINITION TEMPLATE (For Child Repos)
# ═══════════════════════════════════════════════════════════════════════════════
# Child repos MUST use this template when defining domain-specific tools.
# Add domain-specific tools to: doctrine/REPO_DOMAIN_SPEC.md
# ═══════════════════════════════════════════════════════════════════════════════

tool_definition_template:
  description: |
    Child repos define domain-specific tools in their REPO_DOMAIN_SPEC.md.
    Use this template structure for consistency.

  template: |
    # In doctrine/REPO_DOMAIN_SPEC.md, add:

    ## Domain-Specific Tools

    tools:
      [ToolName]:
        tool_id: "[TOOL-DOMAIN-NNN]"
        tier: [0|1|2]
        status: "active"
        software:
          primary: "[primary library or API]"
          dependencies: ["[dep1]", "[dep2]"]
          vendor: "[vendor name or null]"
          requires_api_key: [true|false]
          api_key_source: "[ENV_VAR_NAME]"
        purpose:
          summary: "[one-line summary]"
          what_it_does:
            - "[capability 1]"
            - "[capability 2]"
        consumers:
          - "[sub-hub or module that uses this tool]"
        gate:  # Required for Tier 2
          required_conditions:
            - "[condition 1]"
            - "[condition 2]"
        throttle:
          rate_limits:
            - {scope: "[scope]", limit: [N]}
          cost: {model: "[free|per_call|monthly_fixed]", estimated_cost_per_call: [N]}
          backoff: {strategy: "[none|linear|exponential|fixed]", initial_delay_ms: [N], max_retries: [N]}
        guardrails:
          kill_switch: {trigger: "[condition]", action: "[action]"}

  required_fields:
    - tool_id
    - tier
    - status
    - software.primary
    - purpose.summary
    - throttle.rate_limits
    - guardrails.kill_switch

  notes:
    - "Tool IDs for domain tools use format: TOOL-[DOMAIN]-NNN"
    - "All Tier 2 tools MUST have gate conditions"
    - "Consumers list who within YOUR repo uses this tool"
    - "Do NOT reference other repos in consumers"

# ═══════════════════════════════════════════════════════════════════════════════
# CLAUDE CODE INSTRUCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

claude_instructions: |
  BEFORE suggesting ANY tool, library, or vendor:

  1. CHECK BANNED LIST FIRST
     - If banned → STOP, suggest approved alternative

  2. CHECK TIER 0 (FREE) FIRST
     - Can this be done with existing free tools?

  3. CHECK TIER 1 (CHEAP) SECOND
     - Already paying for Composio, Firecrawl free tier, ScraperAPI

  4. CHECK TIER 2 (SURGICAL) LAST
     - Require gate conditions defined in REPO_DOMAIN_SPEC.md

  5. IF NOT LISTED → ASK, may need ADR

  WHEN IMPLEMENTING:
  - Always implement throttle from spec
  - Always implement kill switch from spec
  - Respect gate conditions for Tier 2 tools
  - Gate conditions are defined BY THE CHILD REPO, not this file

# ═══════════════════════════════════════════════════════════════════════════════
# MAINTENANCE — QUARTERLY REVIEW
# ═══════════════════════════════════════════════════════════════════════════════

maintenance:
  review_frequency: "quarterly"
  next_review: "2026-Q2"

  quarterly_checklist:
    - id: "M-001"
      check: "Generic tool inventory still appropriate"
      action: "Review if tools should be promoted to/demoted from generic"

    - id: "M-002"
      check: "Tier assignments still accurate"
      action: "Review pricing changes, adjust tiers if costs changed"

    - id: "M-003"
      check: "Banned list still valid"
      action: "Review banned vendors for pricing changes or alternatives"

    - id: "M-004"
      check: "Rate limits still appropriate"
      action: "Check actual usage against limits, adjust if needed"

    - id: "M-005"
      check: "API keys rotated"
      action: "Verify all Tier 1/2 API keys rotated per schedule"

    - id: "M-006"
      check: "Kill switches tested"
      action: "Verify all kill switches function correctly"

    - id: "M-007"
      check: "New tools evaluated"
      action: "Review any new tool requests, create ADRs if approved"

  review_output: |
    After quarterly review, update:
    - last_updated field at top of file
    - next_review field in maintenance section
    - Create ADR for any tool additions/removals
    - Log review completion in sovereign audit trail
